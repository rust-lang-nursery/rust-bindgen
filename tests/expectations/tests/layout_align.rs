/* automatically generated by rust-bindgen */


#![allow(dead_code, non_snake_case, non_camel_case_types, non_upper_case_globals)]


#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __IncompleteArrayField<T> {}
#[repr(C)]
#[derive(Debug)]
pub struct rte_kni_fifo {
    /// < Next position to be written
    pub write: ::std::os::raw::c_uint,
    /// < Next position to be read
    pub read: ::std::os::raw::c_uint,
    /// < Circular buffer length
    pub len: ::std::os::raw::c_uint,
    /// < Pointer size - for 32/64 bit OS
    pub elem_size: ::std::os::raw::c_uint,
    /// < The buffer contains mbuf pointers
    pub buffer: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_rte_kni_fifo() {
    assert_eq!(
        ::std::mem::size_of::<rte_kni_fifo>(),
        16usize,
        concat!("Size of: ", stringify!(rte_kni_fifo))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_kni_fifo>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_kni_fifo))
    );
}
impl Default for rte_kni_fifo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rte_eth_link {
    pub _bindgen_opaque_blob: u64,
}
#[test]
fn bindgen_test_layout_rte_eth_link() {
    assert_eq!(
        ::std::mem::size_of::<rte_eth_link>(),
        8usize,
        concat!("Size of: ", stringify!(rte_eth_link))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_eth_link>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_eth_link))
    );
}
impl Clone for rte_eth_link {
    fn clone(&self) -> Self {
        *self
    }
}
