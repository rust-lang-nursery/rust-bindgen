/* automatically generated by rust-bindgen */


#![allow(dead_code, non_snake_case, non_camel_case_types, non_upper_case_globals)]


pub const RTE_CACHE_LINE_SIZE: ::std::os::raw::c_uint = 64;
pub const RTE_MEMPOOL_OPS_NAMESIZE: ::std::os::raw::c_uint = 32;
pub const RTE_MEMPOOL_MAX_OPS_IDX: ::std::os::raw::c_uint = 16;
pub const RTE_HEAP_NUM_FREELISTS: ::std::os::raw::c_uint = 13;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rte_mempool {
    _unused: [u8; 0],
}
/// Prototype for implementation specific data provisioning function.
///
/// The function should provide the implementation specific memory for
/// for use by the other mempool ops functions in a given mempool ops struct.
/// E.g. the default ops provides an instance of the rte_ring for this purpose.
/// it will most likely point to a different type of data structure, and
/// will be transparent to the application programmer.
/// This function should set mp->pool_data.
pub type rte_mempool_alloc_t = ::std::option::Option<
    unsafe extern "C" fn(mp: *mut rte_mempool) -> ::std::os::raw::c_int,
>;
/// Free the opaque private data pointed to by mp->pool_data pointer.
pub type rte_mempool_free_t = ::std::option::Option<unsafe extern "C" fn(mp: *mut rte_mempool)>;
/// Enqueue an object into the external pool.
pub type rte_mempool_enqueue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *const *const ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
/// Dequeue an object from the external pool.
pub type rte_mempool_dequeue_t = ::std::option::Option<
    unsafe extern "C" fn(
        mp: *mut rte_mempool,
        obj_table: *mut *mut ::std::os::raw::c_void,
        n: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int,
>;
/// Return the number of available objects in the external pool.
pub type rte_mempool_get_count = ::std::option::Option<
    unsafe extern "C" fn(mp: *const rte_mempool)
        -> ::std::os::raw::c_uint,
>;
/// Structure defining mempool operations structure
#[repr(C)]
pub struct rte_mempool_ops {
    pub _bindgen_opaque_blob: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_ops() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_ops>(),
        128usize,
        concat!("Size of: ", stringify!(rte_mempool_ops))
    );
}
impl Default for rte_mempool_ops {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// The rte_spinlock_t type.
#[repr(C)]
#[derive(Debug, Default, Copy, Hash, PartialEq, Eq)]
pub struct rte_spinlock_t {
    /// < lock status 0 = unlocked, 1 = locked
    pub locked: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rte_spinlock_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_spinlock_t>(),
        4usize,
        concat!("Size of: ", stringify!(rte_spinlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_spinlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_spinlock_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const rte_spinlock_t)).locked as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_spinlock_t),
            "::",
            stringify!(locked)
        )
    );
}
impl Clone for rte_spinlock_t {
    fn clone(&self) -> Self {
        *self
    }
}
/// Structure storing the table of registered ops structs, each of which contain
/// the function pointers for the mempool ops functions.
/// Each process has its own storage for this ops struct array so that
/// the mempools can be shared across primary and secondary processes.
/// The indices used to access the array are valid across processes, whereas
/// any function pointers stored directly in the mempool struct would not be.
/// This results in us simply having "ops_index" in the mempool struct.
#[repr(C)]
pub struct rte_mempool_ops_table {
    pub _bindgen_opaque_blob: [u8; 2112usize],
}
#[test]
fn bindgen_test_layout_rte_mempool_ops_table() {
    assert_eq!(
        ::std::mem::size_of::<rte_mempool_ops_table>(),
        2112usize,
        concat!("Size of: ", stringify!(rte_mempool_ops_table))
    );
}
impl Default for rte_mempool_ops_table {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// Structure to hold malloc heap
#[repr(C)]
pub struct malloc_heap {
    pub _bindgen_opaque_blob: [u8; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Hash, PartialEq, Eq)]
pub struct malloc_heap__bindgen_ty_1 {
    pub lh_first: *mut malloc_elem,
}
#[test]
fn bindgen_test_layout_malloc_heap__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<malloc_heap__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(malloc_heap__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<malloc_heap__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(malloc_heap__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(0 as *const malloc_heap__bindgen_ty_1)).lh_first as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(malloc_heap__bindgen_ty_1),
            "::",
            stringify!(lh_first)
        )
    );
}
impl Clone for malloc_heap__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl Default for malloc_heap__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_malloc_heap() {
    assert_eq!(
        ::std::mem::size_of::<malloc_heap>(),
        128usize,
        concat!("Size of: ", stringify!(malloc_heap))
    );
}
impl Default for malloc_heap {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Hash, PartialEq, Eq)]
pub struct malloc_elem {
    pub _address: u8,
}
impl Clone for malloc_elem {
    fn clone(&self) -> Self {
        *self
    }
}
