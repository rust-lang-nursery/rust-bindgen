/* automatically generated by rust-bindgen */


#![allow(dead_code, non_snake_case, non_camel_case_types, non_upper_case_globals)]


#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const RTE_CACHE_LINE_MIN_SIZE: ::std::os::raw::c_uint = 64;
pub const RTE_CACHE_LINE_SIZE: ::std::os::raw::c_uint = 64;
pub type phys_addr_t = u64;
pub type MARKER = [*mut ::std::os::raw::c_void; 0usize];
pub type MARKER8 = [u8; 0usize];
pub type MARKER64 = [u64; 0usize];
/// The atomic counter structure.
#[repr(C)]
#[derive(Debug, Default, Copy, Hash, PartialEq, Eq)]
pub struct rte_atomic16_t {
    /// < An internal counter value.
    pub cnt: i16,
}
#[test]
fn bindgen_test_layout_rte_atomic16_t() {
    assert_eq!(
        ::std::mem::size_of::<rte_atomic16_t>(),
        2usize,
        concat!("Size of: ", stringify!(rte_atomic16_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_atomic16_t>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_atomic16_t))
    );
    assert_eq!(
        unsafe { &(*(0 as *const rte_atomic16_t)).cnt as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_atomic16_t),
            "::",
            stringify!(cnt)
        )
    );
}
impl Clone for rte_atomic16_t {
    fn clone(&self) -> Self {
        *self
    }
}
/// The generic rte_mbuf, containing a packet mbuf.
#[repr(C)]
pub struct rte_mbuf {
    pub _bindgen_opaque_blob: [u8; 128usize],
}
/// 16-bit Reference counter.
/// It should only be accessed using the following functions:
/// rte_mbuf_refcnt_update(), rte_mbuf_refcnt_read(), and
/// rte_mbuf_refcnt_set(). The functionality of these functions (atomic,
/// or non-atomic) is controlled by the CONFIG_RTE_MBUF_REFCNT_ATOMIC
/// config option.
#[repr(C)]
#[derive(Debug, Default, Copy, Hash, PartialEq, Eq)]
pub struct rte_mbuf__bindgen_ty_1 {
    /// < Atomically accessed refcnt
    pub refcnt_atomic: __BindgenUnionField<rte_atomic16_t>,
    /// < Non-atomically accessed refcnt
    pub refcnt: __BindgenUnionField<u16>,
    pub bindgen_union_field: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(0 as *const rte_mbuf__bindgen_ty_1)).refcnt_atomic as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_1),
            "::",
            stringify!(refcnt_atomic)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const rte_mbuf__bindgen_ty_1)).refcnt as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_1),
            "::",
            stringify!(refcnt)
        )
    );
}
impl Clone for rte_mbuf__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Hash, PartialEq, Eq)]
pub struct rte_mbuf__bindgen_ty_2 {
    /// < L2/L3/L4 and tunnel information.
    pub packet_type: __BindgenUnionField<u32>,
    pub __bindgen_anon_1: __BindgenUnionField<rte_mbuf__bindgen_ty_2__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Hash, PartialEq, Eq)]
pub struct rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: [u8; 4usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
impl Clone for rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl rte_mbuf__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn l2_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0xf as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_l2_type(&mut self, val: u32) {
        let mask = 0xf as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn l3_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0xf0 as u32;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_l3_type(&mut self, val: u32) {
        let mask = 0xf0 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn l4_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0xf00 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_l4_type(&mut self, val: u32) {
        let mask = 0xf00 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn tun_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0xf000 as u32;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_tun_type(&mut self, val: u32) {
        let mask = 0xf000 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn inner_l2_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0xf0000 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_inner_l2_type(&mut self, val: u32) {
        let mask = 0xf0000 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn inner_l3_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0xf00000 as u32;
        let val = (unit_field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_inner_l3_type(&mut self, val: u32) {
        let mask = 0xf00000 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 20usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn inner_l4_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        let mask = 0xf000000 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_inner_l4_type(&mut self, val: u32) {
        let mask = 0xf000000 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u32 as *mut u8,
                ::std::mem::size_of::<u32>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u32>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_type: u32,
        l3_type: u32,
        l4_type: u32,
        tun_type: u32,
        inner_l2_type: u32,
        inner_l3_type: u32,
        inner_l4_type: u32,
    ) -> u32 {
        (((((((0 | ((l2_type as u32 as u32) << 0usize) & (0xf as u32))
            | ((l3_type as u32 as u32) << 4usize) & (0xf0 as u32))
            | ((l4_type as u32 as u32) << 8usize) & (0xf00 as u32))
            | ((tun_type as u32 as u32) << 12usize) & (0xf000 as u32))
            | ((inner_l2_type as u32 as u32) << 16usize) & (0xf0000 as u32))
            | ((inner_l3_type as u32 as u32) << 20usize) & (0xf00000 as u32))
            | ((inner_l4_type as u32 as u32) << 24usize) & (0xf000000 as u32))
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(0 as *const rte_mbuf__bindgen_ty_2)).packet_type as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_2),
            "::",
            stringify!(packet_type)
        )
    );
}
impl Clone for rte_mbuf__bindgen_ty_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Hash, PartialEq, Eq)]
pub struct rte_mbuf__bindgen_ty_3 {
    /// < RSS hash result if RSS enabled
    pub rss: __BindgenUnionField<u32>,
    /// < Filter identifier if FDIR enabled
    pub fdir: __BindgenUnionField<rte_mbuf__bindgen_ty_3__bindgen_ty_1>,
    /// < Hierarchical scheduler
    pub sched: __BindgenUnionField<rte_mbuf__bindgen_ty_3__bindgen_ty_2>,
    /// < User defined tags. See rte_distributor_process()
    pub usr: __BindgenUnionField<u32>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Hash, PartialEq, Eq)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub hi: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Hash, PartialEq, Eq)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1:
        __BindgenUnionField<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>,
    pub lo: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Hash, PartialEq, Eq)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u16,
    pub id: u16,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)).hash
                as *const _ as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)).id
                as *const _ as usize
        },
        2usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(id)
        )
    );
}
impl Clone for rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(0 as *const rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1)).lo as *const _
                as usize
        },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(lo)
        )
    );
}
impl Clone for rte_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const rte_mbuf__bindgen_ty_3__bindgen_ty_1)).hi as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(hi)
        )
    );
}
impl Clone for rte_mbuf__bindgen_ty_3__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Hash, PartialEq, Eq)]
pub struct rte_mbuf__bindgen_ty_3__bindgen_ty_2 {
    pub lo: u32,
    pub hi: u32,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const rte_mbuf__bindgen_ty_3__bindgen_ty_2)).lo as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_2),
            "::",
            stringify!(lo)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const rte_mbuf__bindgen_ty_3__bindgen_ty_2)).hi as *const _ as usize },
        4usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_3__bindgen_ty_2),
            "::",
            stringify!(hi)
        )
    );
}
impl Clone for rte_mbuf__bindgen_ty_3__bindgen_ty_2 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(0 as *const rte_mbuf__bindgen_ty_3)).rss as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_3),
            "::",
            stringify!(rss)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const rte_mbuf__bindgen_ty_3)).fdir as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_3),
            "::",
            stringify!(fdir)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const rte_mbuf__bindgen_ty_3)).sched as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_3),
            "::",
            stringify!(sched)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const rte_mbuf__bindgen_ty_3)).usr as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_3),
            "::",
            stringify!(usr)
        )
    );
}
impl Clone for rte_mbuf__bindgen_ty_3 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Hash, PartialEq, Eq)]
pub struct rte_mbuf__bindgen_ty_4 {
    /// < Can be used for external metadata
    pub userdata: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    /// < Allow 8-byte userdata on 32-bit
    pub udata64: __BindgenUnionField<u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_4>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(0 as *const rte_mbuf__bindgen_ty_4)).userdata as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_4),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { &(*(0 as *const rte_mbuf__bindgen_ty_4)).udata64 as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_4),
            "::",
            stringify!(udata64)
        )
    );
}
impl Clone for rte_mbuf__bindgen_ty_4 {
    fn clone(&self) -> Self {
        *self
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Hash, PartialEq, Eq)]
pub struct rte_mbuf__bindgen_ty_5 {
    /// < combined for easy fetch
    pub tx_offload: __BindgenUnionField<u64>,
    pub __bindgen_anon_1: __BindgenUnionField<rte_mbuf__bindgen_ty_5__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Hash, PartialEq, Eq)]
pub struct rte_mbuf__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_1: [u16; 4usize],
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(rte_mbuf__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rte_mbuf__bindgen_ty_5__bindgen_ty_1)
        )
    );
}
impl Clone for rte_mbuf__bindgen_ty_5__bindgen_ty_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl rte_mbuf__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn l2_len(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x7f as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_l2_len(&mut self, val: u64) {
        let mask = 0x7f as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn l3_len(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0xff80 as u64;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_l3_len(&mut self, val: u64) {
        let mask = 0xff80 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn l4_len(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0xff0000 as u64;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_l4_len(&mut self, val: u64) {
        let mask = 0xff0000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn tso_segsz(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0xffff000000 as u64;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_tso_segsz(&mut self, val: u64) {
        let mask = 0xffff000000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn outer_l3_len(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0x1ff0000000000 as u64;
        let val = (unit_field_val & mask) >> 40usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_outer_l3_len(&mut self, val: u64) {
        let mask = 0x1ff0000000000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 40usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn outer_l2_len(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        let mask = 0xfe000000000000 as u64;
        let val = (unit_field_val & mask) >> 49usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_outer_l2_len(&mut self, val: u64) {
        let mask = 0xfe000000000000 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                ::std::mem::size_of::<u64>(),
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 49usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                ::std::mem::size_of::<u64>(),
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        l2_len: u64,
        l3_len: u64,
        l4_len: u64,
        tso_segsz: u64,
        outer_l3_len: u64,
        outer_l2_len: u64,
    ) -> u64 {
        ((((((0 | ((l2_len as u64 as u64) << 0usize) & (0x7f as u64))
            | ((l3_len as u64 as u64) << 7usize) & (0xff80 as u64))
            | ((l4_len as u64 as u64) << 16usize) & (0xff0000 as u64))
            | ((tso_segsz as u64 as u64) << 24usize) & (0xffff000000 as u64))
            | ((outer_l3_len as u64 as u64) << 40usize) & (0x1ff0000000000 as u64))
            | ((outer_l2_len as u64 as u64) << 49usize) & (0xfe000000000000 as u64))
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf__bindgen_ty_5>(),
        8usize,
        concat!("Size of: ", stringify!(rte_mbuf__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<rte_mbuf__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(rte_mbuf__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { &(*(0 as *const rte_mbuf__bindgen_ty_5)).tx_offload as *const _ as usize },
        0usize,
        concat!(
            "Alignment of field: ",
            stringify!(rte_mbuf__bindgen_ty_5),
            "::",
            stringify!(tx_offload)
        )
    );
}
impl Clone for rte_mbuf__bindgen_ty_5 {
    fn clone(&self) -> Self {
        *self
    }
}
#[test]
fn bindgen_test_layout_rte_mbuf() {
    assert_eq!(
        ::std::mem::size_of::<rte_mbuf>(),
        128usize,
        concat!("Size of: ", stringify!(rte_mbuf))
    );
}
impl Default for rte_mbuf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
/// < Pool from which mbuf was allocated.
#[repr(C)]
#[derive(Debug, Default, Copy, Hash, PartialEq, Eq)]
pub struct rte_mempool {
    pub _address: u8,
}
impl Clone for rte_mempool {
    fn clone(&self) -> Self {
        *self
    }
}
