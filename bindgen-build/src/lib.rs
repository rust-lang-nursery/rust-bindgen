#[macro_use]
extern crate failure;
extern crate cc;
extern crate syn;

use std::env;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;
use std::result::Result as StdResult;

type Result<T> = StdResult<T, failure::Error>;

pub fn build<P, S, F>(path: P, name: S, config: F) -> Result<()>
where
    P: AsRef<Path>,
    S: AsRef<str>,
    F: FnOnce(&mut cc::Build),
{
    let mut gen = Generator::default();

    // parse and extract C/C++ code
    {
        let mut f = File::open(path)?;
        let mut content = String::new();
        f.read_to_string(&mut content)?;
        let ast = syn::parse_file(&content)?;
        syn::visit::visit_file(&mut gen, &ast);
    }

    let mut build = cc::Build::new();
    build
        .cpp(gen.saw_cpp)
        .static_flag(true)
        .cargo_metadata(true);

    // apply user configuration
    config(&mut build);

    // generate the C/C++ wrapper file
    {
        let out_dir = env::var("OUT_DIR")?;
        let out_file = Path::new(&out_dir).join(&format!(
            "{}.{}",
            name.as_ref(),
            if gen.saw_cpp { "cpp" } else { "c" }
        ));
        build.file(&out_file);

        let mut f = File::create(out_file)?;
        writeln!(f, "// generated by bindgen; DO NOT EDIT\n")?;
        writeln!(f, "#pragma GCC diagnostic push")?;
        writeln!(f, "#pragma GCC diagnostic ignored \"-Wdeprecated-declarations\"")?;
        writeln!(f, "{}", gen.code)?;
        writeln!(f, "#pragma GCC diagnostic pop")?;
    }

    // build the C/C++ wrapper file
    build
        .try_compile(&format!("lib{}.a", name.as_ref()))
        .map_err(|err| format_err!("fail to build, {:?}", err))?;

    Ok(())
}

#[derive(Debug, Default)]
struct Generator {
    code: String,
    saw_cpp: bool,
}

impl<'ast> syn::visit::Visit<'ast> for Generator {
    fn visit_item_macro(&mut self, item: &'ast syn::ItemMacro) {
        if item.mac.path.is_ident("c") || item.mac.path.is_ident("cpp") {
            self.code.push_str(
                item.mac
                    .tts
                    .to_string()
                    .trim_start_matches('{')
                    .trim_end_matches('}'),
            );
            self.code.push_str("\n");
            self.saw_cpp |= item.mac.path.is_ident("cpp");
        }
    }
}
